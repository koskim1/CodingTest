#include <bits/stdc++.h>
using namespace std;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    //버퍼플러시 전
    for (int i = 1; i <= 5; ++i) {
        cout << i << "\n";
    }
    cout << endl;
    // 버퍼 플러시 후
    for (int i = 1; i <= 5; ++i) {
        cout << i << "\n" << flush;
    }
    cout << endl;

    // 버퍼 플러시 후 : 위와 동일한 코드
    for (int i = 1; i <= 5; ++i) {
        cout << i << endl;
    }
    cout << endl;

/*
endl보다는 ‘\n’을 쓰는 것이 속도측면에서 좋습니다. endl은 ‘\n’ + 버퍼플러시라고 생각하면 됩니다. 출력 싱크를 보다 “정확하게”만들어줍니다.

여기서 버퍼플러시란 임시 저장 영역에서 컴퓨터의 영구 메모리로 컴퓨터 데이터를 전송하는 것을 말합니다.

파일을 변경하면 한 컴퓨터 화면에서 볼 수 있는 변경 사항이 일시적으로 버퍼에 저장되고 사용자에 작업에 의해 하드디스크라는 영구저장소로 플러시될지, 소멸될지가 정해집니다.

예를 들어 워드문서를 열어 임시 파일을 생성했을 때 그냥 “저장하지 않고 닫기”를 하게되면 자동으로 소멸됩니다. 
그러나 저장하게 되면 해당 문서에 대한 변경 사항이 버퍼에서 하드디스크의 영구저장소로 플러시됩니다.




위 코드를 보면 <<”\n”; 와 “\n” << flush; 와 << endl;가 있습니다.

“\n” << flush; 와 << endl;는 같다고 보시면 됩니다. 즉, endl은 “\n”에 플러시가 추가된 것이죠.

<<”\n”;의 경우 한개씩 1,2,3,4,5 가 나와야 하는데 “ 어떤 경우에는 “ 한번에 출력이 될 수도 있습니다.

플러시는 이를 무조건 순차적으로 출력되게 해주는 것이죠. 왜냐면 콘솔창으로 바로 “출력을 플러시” 해주는 역할을 하기 때문입니다.

이 차이입니다.

그러나 코딩테스트에는 이러한 출력의 정확한 “시간적 차이”는 중요하지 않습니다.

어쨌듯 1,2,3,4,5 순차적으로 출력이 되기 떄문에 좀 더 빠른 것을 써야 하는 코딩테스트 특성상 버퍼플러시가 들어가있지 않는 “\n”을 쓰는 것이 좋습니다.

코딩테스트는 빠르게 푸는 것이 중요하다는 사실을 잊지 마세요. 🙂
*/
}
